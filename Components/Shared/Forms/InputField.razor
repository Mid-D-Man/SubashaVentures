@* Components/Shared/Forms/InputField.razor - FIXED INPUT BINDING *@

<div class="input-field @(HasError ? "has-error" : "") @(IsDisabled ? "disabled" : "") @CssClass">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="input-label">
            @Label
            @if (IsRequired)
            {
                <span class="required-mark">*</span>
            }
        </label>
    }
    
    <div class="input-wrapper">
        @if (!string.IsNullOrEmpty(PrefixIcon))
        {
            <span class="input-prefix">@PrefixIcon</span>
        }
        
        <input type="@Type"
               class="input-control @(Size.ToString().ToLower())"
               placeholder="@Placeholder"
               value="@Value"
               disabled="@IsDisabled"
               readonly="@IsReadOnly"
               required="@IsRequired"
               maxlength="@(MaxLength > 0 ? MaxLength : (int?)null)"
               @oninput="HandleInput"
               @onblur="HandleBlur"
               @onfocus="HandleFocus" />
        
        @if (!string.IsNullOrEmpty(SuffixIcon))
        {
            <span class="input-suffix">@SuffixIcon</span>
        }
        
        @if (ShowClearButton && !string.IsNullOrEmpty(Value))
        {
            <button type="button" 
                    class="clear-btn" 
                    @onclick="ClearInput" 
                    @onclick:stopPropagation="true"
                    tabindex="-1">
                âœ•
            </button>
        }
    </div>
    
    @if (!string.IsNullOrEmpty(HelperText) && !HasError)
    {
        <span class="helper-text">@HelperText</span>
    }
    
    @if (HasError && !string.IsNullOrEmpty(ErrorMessage))
    {
        <span class="error-message">@ErrorMessage</span>
    }
    
    @if (ShowCharacterCount && MaxLength > 0)
    {
        <span class="character-count">@(Value?.Length ?? 0) / @MaxLength</span>
    }
</div>

@code {
    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public string Type { get; set; } = "text";
    [Parameter] public string? PrefixIcon { get; set; }
    [Parameter] public string? SuffixIcon { get; set; }
    [Parameter] public string? HelperText { get; set; }
    [Parameter] public string? ErrorMessage { get; set; }
    [Parameter] public bool HasError { get; set; } = false;
    [Parameter] public bool IsRequired { get; set; } = false;
    [Parameter] public bool IsDisabled { get; set; } = false;
    [Parameter] public bool IsReadOnly { get; set; } = false;
    [Parameter] public bool ShowClearButton { get; set; } = false;
    [Parameter] public bool ShowCharacterCount { get; set; } = false;
    [Parameter] public int MaxLength { get; set; } = 0;
    [Parameter] public InputSize Size { get; set; } = InputSize.Medium;
    [Parameter] public string CssClass { get; set; } = "";
    [Parameter] public EventCallback OnBlur { get; set; }
    [Parameter] public EventCallback OnFocus { get; set; }

    public enum InputSize
    {
        Small,
        Medium,
        Large
    }

    // FIXED: Proper event handling for oninput
    private void HandleInput(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString() ?? "";
        
        // Update local value immediately
        Value = newValue;
        
        // Notify parent component - use InvokeAsync for proper rendering
        InvokeAsync(async () =>
        {
            await ValueChanged.InvokeAsync(newValue);
            StateHasChanged();
        });
    }

    private async Task HandleBlur(FocusEventArgs e)
    {
        if (OnBlur.HasDelegate)
        {
            await OnBlur.InvokeAsync();
        }
    }

    private async Task HandleFocus(FocusEventArgs e)
    {
        if (OnFocus.HasDelegate)
        {
            await OnFocus.InvokeAsync();
        }
    }

    private void ClearInput()
    {
        Value = "";
        InvokeAsync(async () =>
        {
            await ValueChanged.InvokeAsync("");
            StateHasChanged();
        });
    }
}
